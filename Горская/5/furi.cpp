#include <iostream>
#include <vector>
#include <cmath>
#include <functional>
#include <cstdio>

// Если M_PI не определён в системе, задаём его вручную.
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// ====================================================================================
// Функция simpsonIntegration реализует численное интегрирование по методу Симпсона.
// Этот метод аппроксимирует интеграл, используя параболы (квадратичные полиномы) для более
// точного представления кривой функции. Он обычно работает заметно лучше простого метода
// прямоугольников, особенно если функция гладкая.
// ====================================================================================
double simpsonIntegration(const std::function<double(double)>& func, double a, double b, int n) {
    // Метод Симпсона требует, чтобы число разбиений n было чётным.
    if (n % 2 != 0) {
        n++;  // Если n нечётное, увеличим его на 1.
    }
    double h = (b - a) / n;         // Вычисляем шаг разбиения.
    double s = func(a) + func(b);   // Начинаем с суммирования значений функции в концах интервала.
    
    // Цикл перебирает все промежуточные точки.
    // При нечётных индексах умножаем значение функции на 4,
    // при чётных – на 2, согласно формуле Симпсона.
    for (int i = 1; i < n; i++) {
        double x = a + i * h;
        if (i % 2 == 0) {
            s += 2 * func(x);
        } else {
            s += 4 * func(x);
        }
    }
    // Финальное умножение на (h/3) даёт итоговое приближение интеграла.
    return s * h / 3;
}

// ====================================================================================
// Функция main() реализует разложение функции в ряд Фурье на отрезке [0, 2π],
// используя метод Симпсона для численного интегрирования при нахождении коэффициентов.
// ====================================================================================
int main() {
    // Устанавливаем нужную локаль для корректного вывода русских символов.
    setlocale(LC_ALL, "ru");

    /* 
       Принцип работы ряда Фурье можно сравнить с разложением сложной музыкальной композиции
       на отдельные ноты. Здесь рассматривается функция f(x) = x, определённая на отрезке [0, 2π].
       Эта функция, периодически повторяющаяся с периодом 2π, имеет форму пилы (sawtooth wave). 
       Ряд Фурье позволяет представлять её как сумму простых синусоидальных функций.
    */
    
    // Определяем исходную функцию f(x) = x.
    auto func = [](double x) -> double {
        return x;
    };

    // Определяем период функции. Здесь период равен 2π, то есть от 0 до 2π.
    double period = 2 * M_PI;

    // Задаём количество гармоник, участвующих в разложении.
    // Чем больше гармоник, тем точнее приближение, но выше вычислительная нагрузка.
    int harmonics = 500;

    // Вычисляем угловую частоту ω = 2π / период. 
    // При period = 2π получаем ω = 1.
    double omega = 2 * M_PI / period;

    // Задаём количество разбиений интервала для численного интегрирования методом Симпсона.
    // Чем больше разбиений, тем точнее вычисление интегралов.
    int integrationSteps = 2000;
    
    // Создаем векторы для хранения коэффициентов Фурье.
    // coeffA[0] хранит значение a0, а для n >= 1 coeffA[n] и coeffB[n] – остальные коэффициенты.
    std::vector<double> coeffA(harmonics + 1, 0.0);
    std::vector<double> coeffB(harmonics + 1, 0.0); // coeffB[0] не используется по определению.

    // --------------------------------------------------------------------------------
    // Вычисление коэффициента a0, который является средним значением функции на интервале.
    // Формула: a0 = (1/период) * ∫[0, период] f(x) dx.
    // --------------------------------------------------------------------------------
    coeffA[0] = (1.0 / period) * simpsonIntegration(func, 0, period, integrationSteps);
    std::cout << "a0 = " << coeffA[0] << std::endl;

    // --------------------------------------------------------------------------------
    // Вычисление коэффициентов a_n и b_n для каждой гармоники (n = 1 ... harmonics).
    // Формулы:
    // a_n = (2/период) * ∫[0, период] f(x) cos(nωx) dx
    // b_n = (2/период) * ∫[0, период] f(x) sin(nωx) dx
    // Здесь мы используем lambda-функции для формирования интегрируемых функций.
    // --------------------------------------------------------------------------------
    for (int n = 1; n <= harmonics; ++n) {
        // Определяем функцию для интегрирования с косинусной компонентой.
        auto cosComponent = [&, n](double x) -> double {
            return func(x) * std::cos(n * omega * x);
        };
        // Определяем функцию для интегрирования с синусной компонентой.
        auto sinComponent = [&, n](double x) -> double {
            return func(x) * std::sin(n * omega * x);
        };

        // Вычисляем коэффициенты a_n и b_n с использованием метода Симпсона.
        coeffA[n] = (2.0 / period) * simpsonIntegration(cosComponent, 0, period, integrationSteps);
        coeffB[n] = (2.0 / period) * simpsonIntegration(sinComponent, 0, period, integrationSteps);

        std::cout << "a" << n << " = " << coeffA[n] 
                  << ", b" << n << " = " << coeffB[n] << std::endl;
    }

    // --------------------------------------------------------------------------------
    // Подготовка данных для построения графиков: здесь мы вычисляем значения исходной функции
    // и её приближения рядом Фурье в ряде точек на интервале [0, 2π].
    // --------------------------------------------------------------------------------
    int plotPoints = 500; // Число точек вычисления
    std::vector<double> x_vals(plotPoints + 1);
    std::vector<double> y_orig(plotPoints + 1);    // Значения исходной функции f(x)
    std::vector<double> y_fourier(plotPoints + 1);   // Значения приближения через ряд Фурье
    double dx = period / plotPoints;               // Расстояние между соседними точками

    for (int i = 0; i <= plotPoints; i++) {
        double x = i * dx;
        x_vals[i] = x;
        // Вычисляем значение исходной функции (фактически f(x)=x).
        y_orig[i] = func(x);
        // Рассчитываем приближение с помощью ряда Фурье:
        // Начинаем с постоянного члена ряда (a0).
        double approxim = coeffA[0];
        // На каждой итерации прибавляем вклад каждой гармоники.
        for (int n = 1; n <= harmonics; n++) {
            approxim += coeffA[n] * std::cos(n * omega * x) 
                       + coeffB[n] * std::sin(n * omega * x);
        }
        y_fourier[i] = approxim;
    }

    // --------------------------------------------------------------------------------
    // Передача данных в gnuplot для построения графиков.
    // Gnuplot визуализирует два графика: оригинальную функцию и её приближение рядом Фурье.
    // --------------------------------------------------------------------------------
    FILE* gp = popen("gnuplot -persistent", "w");
    if (gp) {
        // Отправляем команды для настройки графика: заголовок, подписи осей и сетку.
        fprintf(gp, "set title 'Функция и её приближение рядом Фурье'\n");
        fprintf(gp, "set xlabel 'x'\n");
        fprintf(gp, "set ylabel 'y'\n");
        fprintf(gp, "set grid\n");
        // Команда plot создаёт два графика: один для исходной функции и второй для приближения.
        fprintf(gp, "plot '-' with lines title 'Оригинальная функция', '-' with lines title 'Приближение ряда Фурье'\n");

        // Передаём данные для графика исходной функции.
        for (int i = 0; i <= plotPoints; i++) {
            fprintf(gp, "%f %f\n", x_vals[i], y_orig[i]);
        }
        fprintf(gp, "e\n");

        // Передаём данные для графика приближения ряда Фурье.
        for (int i = 0; i <= plotPoints; i++) {
            fprintf(gp, "%f %f\n", x_vals[i], y_fourier[i]);
        }
        fprintf(gp, "e\n");
        
        fflush(gp);  // Очищаем поток перед завершением.
        pclose(gp);  // Закрываем соединение с gnuplot.
    } else {
        std::cerr << "Не удалось открыть gnuplot. Убедитесь, что gnuplot установлен." << std::endl;
    }

    // Завершаем выполнение программы.
    return 0;
}
