#include <iostream>
#include <vector>
#include <cmath>
#include <iomanip>
#include <clocale>    // Для setlocale: установка локали для корректного отображения кириллицы.

using namespace std;

// Размер системы: число уравнений и переменных
const int N = 6;

// Точность выхода: если евклидова норма вектора F(x) меньше EPS, решение считается найденным
const double EPS = 1e-6; 

// Максимальное число итераций, которое алгоритм попытается выполнить
const int MAX_ITER = 100; 

// Функция evaluate_system вычисляет значения системы уравнений.
// В нашем случае система определена как: f_i(x) = x_i^2 - 1
// Параметры:
//   - x: вектор текущего приближения.
// Возвращает:
//   - вектор значений функции F(x) для каждого уравнения.
vector<double> evaluate_system(const vector<double>& x) {
    vector<double> f(N);
    for (int i = 0; i < N; ++i) {
        // Для i-го уравнения вычисляем x[i]^2 - 1
        f[i] = x[i] * x[i] - 1.0;
    }
    return f;
}

// Функция compute_jacobian вычисляет приближённую матрицу Якоби системы F(x)
// с использованием центральных конечных разностей.
// Параметры:
//   - x: вектор текущего приближения.
//   - h: малый шаг, используемый для вычисления производной (по умолчанию 1e-5)
// Возвращает:
//   - матрицу J размером N x N, где элемент J[j][i] приблизительно равен ∂f_j/∂x_i.
vector<vector<double>> compute_jacobian(const vector<double>& x, double h = 1e-5) {
    // Инициализируем матрицу Якоби размером N x N
    vector<vector<double>> J(N, vector<double>(N));
    
    // Цикл по переменным x[i]
    for (int i = 0; i < N; ++i) {
        // Создаем копии вектора x для смещений на +h и -h относительно i-го элемента
        vector<double> x_plus = x;
        x_plus[i] += h;  // Смещаем x[i] вправо на h
        vector<double> f_plus = evaluate_system(x_plus); // Вычисляем F(x_plus)
        
        vector<double> x_minus = x;
        x_minus[i] -= h;  // Смещаем x[i] влево на h
        vector<double> f_minus = evaluate_system(x_minus); // Вычисляем F(x_minus)
        
        // Центральная разностная формула для численной оценки производной:
        // ∂f_j/∂x_i ≈ (f_j(x_plus) - f_j(x_minus)) / (2h)
        for (int j = 0; j < N; ++j) {
            J[j][i] = (f_plus[j] - f_minus[j]) / (2 * h);
        }
    }
    return J;
}

// Функция solve_gauss решает систему линейных уравнений A*x = b методом Гаусса с выбором главного элемента.
// Параметры:
//   - A: квадратная матрица коэффициентов системы.
//   - b: вектор правой части.
//   - x: вектор для сохранения найденного решения (по ссылке).
// Возвращает:
//   - true, если решение найдено успешно, и false, если матрица сингулярна (неподходящий случай для деления).
bool solve_gauss(const vector<vector<double>>& A, const vector<double>& b, vector<double>& x) {
    // Создаем копии матрицы и вектора для модификаций (чтобы не менять исходные данные)
    vector<vector<double>> M = A;
    vector<double> y = b;
    int n = A.size();

    // Прямой ход метода Гаусса: приводим матрицу A к верхнетреугольному виду
    for (int i = 0; i < n; ++i) {
        // Выбор ведущего элемента в столбце i для повышения устойчивости решения
        int max_row = i;
        for (int k = i + 1; k < n; ++k) {
            if (abs(M[k][i]) > abs(M[max_row][i]))
                max_row = k;
        }

        // Если ведущий элемент слишком мал, система может быть вырожденной
        if (abs(M[max_row][i]) < 1e-10)
            return false; // Сингулярная матрица, решение невозможно

        // Меняем текущую строку i с найденной строкой с максимальным элементом
        swap(M[i], M[max_row]);
        swap(y[i], y[max_row]);

        // Делим всю строку на опорный элемент для нормализации диагонального элемента к 1
        double pivot = M[i][i];
        for (int j = i; j < n; ++j)
            M[i][j] /= pivot;
        y[i] /= pivot;

        // Обнуляем все элементы в столбце i в других строках, чтобы получить диагональный вид
        for (int k = 0; k < n; ++k) {
            if (k != i && abs(M[k][i]) > 1e-10) {
                double factor = M[k][i];
                for (int j = i; j < n; ++j)
                    M[k][j] -= factor * M[i][j];
                y[k] -= factor * y[i];
            }
        }
    }

    // После прямого хода решение находится в векторе y.
    x = y;
    return true; // Успешное решение
}

// Функция newton_raphson реализует метод Ньютона для решения системы нелинейных уравнений.
// Параметры:
//   - x0: вектор начального приближения (принимается по ссылке и обновляется до найденного решения).
void newton_raphson(vector<double>& x0) {
    int iter = 0; // Счетчик выполненных итераций

    // Основной циклический процесс итераций. Останавливаем итерации, если достигнута точность или превышен максимум итераций.
    while (iter < MAX_ITER) {
        // Вычисляем текущее значение системы F(x)
        vector<double> F = evaluate_system(x0);
        // Вычисляем приближенный Якобиан матрицы J(x) с помощью метода конечных разностей
        vector<vector<double>> J = compute_jacobian(x0);

        // Вычисляем евклидову норму вектора F для проверки условия сходимости
        double norm_F = 0.0;
        for (double fi : F)
            norm_F += fi * fi;
        norm_F = sqrt(norm_F);

        // Если норма меньше заданной точности, считаем, что решение найдено, и выходим из цикла
        if (norm_F < EPS)
            break;

        // Решаем линейную систему J * dx = F, чтобы получить поправку dx
        vector<double> dx(N);
        if (!solve_gauss(J, F, dx)) {
            cout << "Ошибка: сингулярная матрица Якоби." << endl;
            return;
        }

        // Обновляем приближение: x_new = x_old - dx
        for (int i = 0; i < N; ++i) {
            x0[i] -= dx[i];
        }

        iter++; // Увеличиваем счетчик итераций
    }

    // Вывод найденного решения и числа итераций
    cout << "Метод Ньютона-Рафсона:" << endl;
    for (int i = 0; i < N; ++i) {
        cout << "x[" << i << "] ≈ " << fixed << setprecision(6) << x0[i] << endl;
    }
    cout << "Итераций: " << iter << endl;
}

int main() {
    // Устанавливаем кодировку консоли на UTF-8 для корректного отображения русских символов (Windows)
    // Устанавливаем локаль для корректного отображения кириллицы
    setlocale(LC_ALL, "ru_RU.UTF-8");

    // Начальное приближение для решения системы: все x[i] = 0.5
    vector<double> x0 = {-2, -2, 2, 2, -2, -2};

    // Запускаем метод Ньютона для поиска корней системы
    newton_raphson(x0);

    return 0;
}

