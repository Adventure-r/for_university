#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Пример реализации комбинированного метода для нахождения корня уравнения.
Сначала используется метод дихотомии для получения надёжного начального приближения,
после чего переключаются на метод Ньютона для быстрого уточнения корня.
----
Зависимость от начального приближения:

    Медленно сходиться — если начальная точка далеко от корня.

    Разойтись — если x0x_0 попадает в точку с нулевой производной или далеко от зоны сходимости.

    Попасть в цикл — в некоторых случаях может происходить периодическое зацикливание.

"""

def f(x):
    """
    Функция, корень которой мы ищем.
    В данном примере используется функция f(x) = x^2 - 2,
    корень которой равен sqrt(2) ≈ 1.414.
    """
    return pow(2,x) - 4*x

def f_prime(x):
    """
    Производная функции f(x).
    Для f(x) = x^2 - 2 имеем f'(x) = 2*x.
    """
    return x*pow(2,x-1) -4

def bisection_method(f, a, b, tol_bisect=1e-4, max_iter_bisect=100):
    """
    Реализует метод дихотомии (бисекции) для поиска корня уравнения f(x) = 0.
    
    Параметры:
      - f: функция, корень которой ищется.
      - a, b: границы интервала [a, b], внутри которого функция должна менять знак
              (то есть выполняется условие f(a) * f(b) < 0).
      - tol_bisect: требуемая точность – метод завершится, когда длина интервала станет меньше tol_bisect.
      - max_iter_bisect: максимальное количество итераций, допустимое для метода.
      
    Возвращаемое значение:
      - c: приближённое значение корня, найденное методом дихотомии.
    """
    # Проверяем, что функция действительно меняет знак на концах интервала
    if f(a) * f(b) >= 0:
        raise ValueError("Функция должна иметь разные знаки на концах интервала [a, b].")
    
    c = (a + b) / 2.0  # Начальное приближение: середина интервала
    for i in range(max_iter_bisect):
        c = (a + b) / 2.0  # На каждом шаге вычисляем середину текущего интервала
        # Если длина интервала стала меньше заданной точности, то прекращаем итерации
        if abs(b - a) < tol_bisect:
            break
        # Определяем, в какой части [a, c] или [c, b] функция меняет знак,
        # что гарантирует наличие корня в данном подинтервале
        if f(a) * f(c) < 0:
            b = c  # Корень находится в интервале [a, c]
        else:
            a = c  # Корень находится в интервале [c, b]
    return c

def newton_method(f, f_prime, x0, tol_newton=1e-8, max_iter_newton=100):
    """
    Реализует метод Ньютона (метод касательных) для поиска корня уравнения f(x) = 0,
    начиная с приближения x0.
    
    Параметры:
      - f: функция, корень которой ищется.
      - f_prime: производная функции f.
      - x0: начальное приближение (полученное, например, с помощью процесса бисекции).
      - tol_newton: требуемая точность метода – если |f(x)| становится меньше tol_newton, итерации прекращаются.
      - max_iter_newton: максимальное число итераций для метода Ньютона.
      
    Возвращаемое значение:
      - x: уточнённое приближение значения корня.
    """
    x = x0  # Инициализация x начальным приближением
    for i in range(max_iter_newton):
        fx = f(x)  # Вычисляем значение функции в текущей точке
        # Если значение функции достаточно близко к нулю, считаем, что корень найден
        if abs(fx) < tol_newton:
            break
        fpx = f_prime(x)  # Вычисляем значение производной в текущей точке
        # Если производная равна нулю, деление невозможно – завершаем с ошибкой
        if fpx == 0:
            raise ValueError("Нулевая производная обнаружена, метод Ньютона не может продолжаться.")
        # Применяем формулу Ньютона: x_{n+1} = x_n - f(x_n)/f'(x_n)
        x = x - fx / fpx
    return x

def combined_method(f, f_prime, a, b, tol_bisect=1e-4, max_iter_bisect=100, tol_newton=1e-8, max_iter_newton=100):
    """
    Комбинированный метод нахождения корня:
      1. Сначала с помощью метода дихотомии (бисекции) суждаем интервал, содержащий корень.
      2. Затем используем полученную середину интервала в качестве начального приближения для метода Ньютона.
      
    Параметры:
      - f, f_prime: функция и её производная.
      - a, b: границы интервала, в котором находится корень (при условии f(a)*f(b) < 0).
      - tol_bisect: требуемая точность на этапе дихотомии.
      - max_iter_bisect: максимальное число итераций для дихотомии.
      - tol_newton: требуемая точность для метода Ньютона.
      - max_iter_newton: максимальное число итераций для метода Ньютона.
      
    Возвращаемое значение:
      - approx_root: окончательно найденное приближение корня.
    """
    print("Запуск метода дихотомии для сужения интервала с корнем...")
    # Этап 1: находим приближённое значение корня методом дихотомии
    approx_root_bisect = bisection_method(f, a, b, tol_bisect, max_iter_bisect)
    print(f"Результат метода дихотомии: приближенное значение корня = {approx_root_bisect}")

    print("Переключаемся на метод Ньютона для ускорения сходимости...")
    # Этап 2: используем полученное значение в качестве начальной точки для метода Ньютона
    approx_root_newton = newton_method(f, f_prime, approx_root_bisect, tol_newton, max_iter_newton)
    print(f"Результат метода Ньютона: уточненное значение корня = {approx_root_newton}")
    
    return approx_root_newton

if __name__ == "__main__":
    # Определяем интервал [a, b]. Для функции f(x)=x^2-2 корень лежит между 1 и 2.
    a = 3.0
    b = 5.0
    
    # Вызываем комбинированный метод для нахождения корня
    root = combined_method(f, f_prime, a, b)
    
    # Выводим окончательный результат: найденное значение корня и значение функции в этой точке
    print("\nОкончательное приближенное значение корня:", root)
    print("Значение функции в найденном корне: f(root) =", f(root))

