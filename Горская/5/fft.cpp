#include <iostream>
#include <vector>
#include <complex>    // Для работы с комплексными числами
#include <cmath>
#include <cstdio>

// Если M_PI не определён, задаём его вручную
#ifndef M_PI
#define M_PI 3.14159265358979323846
#endif

// =======================================================================
// Функция fft 
// Реализует быстрое преобразование Фурье (FFT) по алгоритму Cooley-Tukey.
// Функция рекурсивно разделяет входной вектор комплексных чисел на чётные и нечётные элементы,
// вычисляет их FFT, а затем объединяет результаты. В итоге получаем спектр частот.
//
// Вход: vector a – набор комплексных чисел (размер должен быть степенью двойки).
// После вызова, вектор a модифицируется и содержит DFT исходного набора.
// =======================================================================
void fft(std::vector<std::complex<double>> &a) {
    int n = a.size();
    if(n <= 1) return;   // Базовый случай рекурсии

    // Разделяем на вектора с чётными и нечётными индексами
    std::vector<std::complex<double>> even(n / 2), odd(n / 2);
    for (int i = 0; i < n / 2; i++) {
        even[i] = a[i * 2];
        odd[i] = a[i * 2 + 1];
    }
    
    // Рекурсивно вычисляем FFT для чётных и нечётных частей
    fft(even);
    fft(odd);
    
    // Комбинируем результаты.
    for (int k = 0; k < n / 2; k++) {
        // Вычисляем «зыбучее» умножение с экспонентой: e^(-2πik/n)
        std::complex<double> t = std::polar(1.0, -2 * M_PI * k / n) * odd[k];
        a[k] = even[k] + t;           // Первый полублок результата
        a[k + n / 2] = even[k] - t;     // Второй полублок результата
    }
}

// =======================================================================
// Функция ifft 
// Вычисляет обратное быстрое преобразование Фурье (iFFT).
// Для этого она сначала берёт комплексное сопряжение всех элементов,
// затем применяет fft, снова берёт сопряжение и делит каждый элемент на размер вектора.
// =======================================================================
void ifft(std::vector<std::complex<double>> &a) {
    int n = a.size();
    // Берем комплексное сопряжение каждого элемента
    for (int i = 0; i < n; i++) {
        a[i] = std::conj(a[i]);
    }
    // Применяем fft к сопряжённым элементам
    fft(a);
    // Ещё раз берем сопряжение и делим на размер для нормировки
    for (int i = 0; i < n; i++) {
        a[i] = std::conj(a[i]) / static_cast<double>(n);
    }
}

// =======================================================================
// Функция main 
//
// В данной функции мы:
// 1. Задаём функцию f(x) = x на интервале [0, 2π].
// 2. Отбираем N дискретных точек (N должно быть степенью двойки) для представления функции.
// 3. Вычисляем FFT, получая частотный спектр функции.
// 4. Выполняем обратное преобразование (ifft), чтобы показать восстановление исходного сигнала.
// 5. Отправляем данные в gnuplot для визуальной проверки.
// =======================================================================
int main() {
    // Устанавливаем локаль для корректного отображения русских символов
    setlocale(LC_ALL, "ru");

    // Количество точек для дискретного представления функции.
    // N должно быть степенью 2 для работы стандартного алгоритма FFT.
    const int N = 1024;
    
    // Задаём период функции. Здесь период = 2π.
    double period = 2 * M_PI;
    // Определяем шаг между точками

    double dx = period / N;
    
    // Векторы для хранения значений: x-координаты, значения исходной функции f(x)
    // и комплексные данные для FFT (изначально только действительная часть).
    std::vector<double> x_vals(N);
    std::vector<double> f_original(N);
    std::vector<std::complex<double>> data(N);
    
auto func = [](double x) -> double {
    return std::sin(2 * x) + 0.5 * std::cos(3 * x);
};

    // Заполняем данные с использованием выбранной функции: f(x) = sin(2x) + 0.5*cos(3x)
    for (int i = 0; i < N; i++) {
        double x = i * dx;
        x_vals[i] = x;
        double val = func(x);  // Вычисляем значение функции в точке x
        f_original[i] = val;
        data[i] = val;         // Мнимая часть остается равной 0
    }
    
    // Сохраняем исходные данные для последующего сравнения (если потребуется)
    std::vector<std::complex<double>> data_copy = data;
    
    // Вычисляем быстрое преобразование Фурье (FFT)
    fft(data);
    
    // Выводим первые 10 коэффициентов FFT для ознакомления
    std::cout << "FFT коэффициенты (первые 10):" << std::endl;
    for (int i = 0; i < 10; i++) {
        std::cout << "Index " << i << ": " << data[i] << std::endl;
    }
    
    // Для проверки корректности вычисления выполняем обратное преобразование (ifft)
    ifft(data);
    
    // После ifft вектор "data" должен содержать восстановленные значения функции.
    std::vector<double> f_reconstructed(N);
    for (int i = 0; i < N; i++) {
        // Берем только действительную часть – мнимая должна быть близка к нулю
        f_reconstructed[i] = data[i].real();
    }
    
    // =======================================================================
    // Передаем данные в gnuplot для построения графиков.
    // Сравниваем исходную функцию и сигнал, восстановленный по обратному FFT.
    // =======================================================================
    FILE* gp = popen("gnuplot -persistent", "w");
    if (gp) {
        fprintf(gp, "set title 'Быстрое преобразование Фурье: Оригинал и восстановленный сигнал'\n");
        fprintf(gp, "set xlabel 'x'\n");
        fprintf(gp, "set ylabel 'f(x)'\n");
        fprintf(gp, "set grid\n");
	
	//Приближение
	fprintf(gp, "set xrange [0:1]\n");  // Устанавливает диапазон по оси x от 0 до 1
	fprintf(gp, "set yrange [0:1]\n");    // Устанавливает диапазон по оси y от 0 до 1

        fprintf(gp, "plot '-' with lines title 'Оригинал', '-' with lines title 'Восстановленный сигнал'\n");
        
        // Передаем данные для исходного сигнала.
        for (int i = 0; i < N; i++) {
            fprintf(gp, "%f %f\n", x_vals[i], f_original[i]);
        }
        fprintf(gp, "e\n");
        
        // Передаем данные для восстановленного сигнала.
        for (int i = 0; i < N; i++) {
            fprintf(gp, "%f %f\n", x_vals[i], f_reconstructed[i]);
        }
        fprintf(gp, "e\n");
        
        fflush(gp);
        pclose(gp);
    } else {
        std::cerr << "Не удалось открыть gnuplot. Убедитесь, что gnuplot установлен." << std::endl;
    }
    
    return 0;
}

