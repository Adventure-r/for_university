#include <iostream>
#include <cmath>
#include <vector>
#include <clocale>    // Для setlocale (корректное отображение русских символов)

using namespace std;

// Определение структуры System для представления первой функции системы уравнений
struct System {
    // Оператор () позволяет использовать объект как функцию
    double operator()(double x, double y) const {
        return cos(y) + x - 1.5; // f(x, y) = cos(y) + x - 1.5
    }
};

// Определение структуры System2 для представления второй функции системы уравнений
struct System2 {
    double operator()(double x, double y) const {
        return 2 * y - sin(x - 0.5) - 1; // g(x, y) = 2y - sin(x - 0.5) - 1
    }
};

// Определение структуры Jacobian для вычисления матрицы Якоби
struct Jacobian {
    vector<vector<double>> operator()(double x, double y) const {
        vector<vector<double>> J(2, vector<double>(2)); // Создание 2x2 матрицы

        // Заполнение матрицы Якоби
        J[0][0] = 1.0;          // Производная f(x, y) по x
        J[0][1] = -sin(y);      // Производная f(x, y) по y
        J[1][0] = -cos(x - 0.5);// Производная g(x, y) по x
        J[1][1] = 2.0;          // Производная g(x, y) по y

        return J;
    }
};

// Функция для решения системы линейных уравнений Ax = b
vector<double> solve_linear(const vector<vector<double>>& A, const vector<double>& b) {
    // Вычисление определителя матрицы
    double det = A[0][0] * A[1][1] - A[0][1] * A[1][0];

    // Проверка на сингулярность (нулевой определитель указывает на невозможность решения)
    if (det == 0) throw runtime_error("Сингулярная матрица");

    // Вычисление решений методом Крамера
    double x = (b[0] * A[1][1] - b[1] * A[0][1]) / det;
    double y = (A[0][0] * b[1] - A[1][0] * b[0]) / det;

    return {x, y}; // Возвращаем найденные значения переменных
}

// Функция для решения системы уравнений методом Ньютона-Рафсона
void newton_system(double x0, double y0, double eps) {
    System F;       // Создание объекта для функции f(x, y)
    System2 G;      // Создание объекта для функции g(x, y)
    Jacobian J;     // Создание объекта для матрицы Якоби

    int iter = 0;   // Счетчик итераций
    double x = x0;  // Начальное приближение x
    double y = y0;  // Начальное приближение y
    vector<double> delta(2); // Вектор для хранения изменений переменных

    while (true) {
        double f_val = F(x, y); // Вычисление значения функции f(x, y)
        double g_val = G(x, y); // Вычисление значения функции g(x, y)

        // Проверка критерия остановки (если значения функций малы, считаем решение найденным)
        if (abs(f_val) < eps && abs(g_val) < eps) break;

        auto jac = J(x, y); // Вычисление матрицы Якоби в текущей точке
        vector<double> b = {-f_val, -g_val}; // Формирование правой части системы Ax = b

        try {
            delta = solve_linear(jac, b); // Решаем систему линейных уравнений
        } catch (...) {
            // Вывод сообщения об ошибке, если матрица Якоби является сингулярной
            cout << "Ошибка: сингулярная матрица" << endl;
            return;
        }

        x += delta[0]; // Обновление значения x
        y += delta[1]; // Обновление значения y

        iter++; // Увеличение счетчика итераций

        // Проверка на слишком большое количество итераций (во избежание бесконечного цикла)
        if (iter > 1000) {
            cout << "Не сходится" << endl;
            return;
        }
    }

    // Вывод результата вычислений
    cout << "Метод Ньютона-Рафсона: x ≈ " << x << ", y ≈ " << y << ", итераций: " << iter << endl;
}

int main() {
    setlocale(LC_ALL, "ru_RU.UTF-8"); // Активация локали для корректного отображения кириллицы

    double x0 = 0.5; // Начальное приближение x
    double y0 = 0.5; // Начальное приближение y
    double eps = 1e-6; // Допустимая погрешность

    newton_system(x0, y0, eps); // Запуск метода Ньютона-Рафсона для решения системы

    return 0; // Завершаем выполнение программы
}

