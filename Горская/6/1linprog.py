import numpy as np

def simplex(c, A, b, tol=1e-9):
    """
    Решатель задачи линейного программирования методом симплекс.
    
    Задача формулируется так:
        max  c^T x
         s.t. A x <= b,  x >= 0
    
    Для применения метода симплекс задачу приводят к стандартной форме с введением 
    дополнительных (слаговых) переменных:
        A x + I s = b,   x, s >= 0,
    где I — единичная матрица.
    
    Параметры:
      c  : вектор коэффициентов целевой функции (исходные переменные);
      A  : матрица коэффициентов ограничений;
      b  : вектор правых частей ограничений.
      tol: допустимая погрешность для сравнения с нулём (по умолчанию 1e-9).
    
    Возвращает:
      opt_x   : оптимальное значение исходных переменных x (без слаговых переменных),
      optimum : оптимальное значение целевой функции,
      T       : финальное симплекс‑табло (для отладки),
      basis   : список индексов базисных переменных для строк ограничений.
    """
    m, n = A.shape  # m — число ограничений, n — число исходных переменных

    # Построение симплекс‑табло размером (m+1) x (n+m+1).
    # Столбцы: [ x1, …, xn, s1, …, sm, RHS ]
    T = np.zeros((m + 1, n + m + 1))
    
    # Заполняем строки ограничений:
    # Первые n столбцов – коэффициенты A, следующие m столбцов – единичная матрица (свободные переменные),
    # последний столбец – вектор b.
    T[:m, :n] = A
    T[:m, n:n + m] = np.eye(m)
    T[:m, -1] = b

    # Целевая функция записывается в последней строке. Поскольку мы решаем задачу 
    # максимизации, а симплекс-метод в этой реализации ищет минимум, то коэффициенты
    # целевой функции берутся с отрицательным знаком.
    T[m, :n] = -c

    # Начальный базис – слаговые переменные с индексами от n до n+m-1.
    basis = list(range(n, n + m))
    
    # Итерационный процесс: пока в строке целевой функции есть отрицательные коэффициенты,
    # продолжаем пивотирование.
    while True:
        # Выбор входящей переменной – ищем столбец с самым отрицательным значением в строке цели.
        col = -1
        min_val = 0
        for j in range(n + m):
            if T[m, j] < min_val - tol:
                min_val = T[m, j]
                col = j
        # Если отрицательных коэффициентов нет – оптимум достигнут.
        if col == -1:
            break

        # Выбор исходящей переменной (строки) по правилу минимального отношения.
        pivot_row = -1
        min_ratio = float('inf')
        for i in range(m):
            if T[i, col] > tol:
                ratio = T[i, -1] / T[i, col]
                if ratio < min_ratio:
                    min_ratio = ratio
                    pivot_row = i
        # Если для выбранного столбца не находится положительный коэффициент в столбце ограничений,
        # задача не ограничена.
        if pivot_row == -1:
            raise ValueError("ЛП-задача не ограничена")
        
        # Пивотирование: делим выбранную строку на опорный элемент,
        # а затем обнуляем столбец пивота в остальных строках.
        pivot = T[pivot_row, col]
        T[pivot_row, :] = T[pivot_row, :] / pivot

        for i in range(m + 1):
            if i != pivot_row:
                T[i, :] = T[i, :] - T[i, col] * T[pivot_row, :]
        
        # Обновляем список базисных переменных: в данной строке теперь базисной является переменная col.
        basis[pivot_row] = col

    # Извлечение оптимального решения: значения переменных, входящих в базис, 
    # записаны в последних столбцах симплекс‑табло.
    x = np.zeros(n + m)
    for i in range(m):
        if basis[i] < n + m:
            x[basis[i]] = T[i, -1]
    optimum = T[m, -1]
    
    # Возвращается оптимальное значение только для исходных переменных.
    return x[:n], optimum, T, basis


if __name__ == "__main__":
    # -----------------------------
    # Входные данные задачи:
    # -----------------------------
    products = ['Π₁', 'Π₂', 'Π₃', 'Π₄']
    income_coeff = np.array([2, 3, 4, 5], dtype=float)  # Доход от единицы продукции

    # Матрица затрат ресурсов (каждая строка соответствует определённому ресурсу)
    resource_coeff = np.array([
        [2, 3, 4, 5],  # Площадь
        [2, 1, 2, 4],  # Труд
        [2, 3, 1, 1]   # Тяга
    ], dtype=float)

    resources_available = np.array([100, 120, 80], dtype=float)  # Доступные ресурсы
    resource_names = ['Площадь', 'Труд', 'Тяга']

    # -----------------------------
    # Решение задачи:
    # -----------------------------
    # Необходимо максимизировать доход: max (2x1 + 3x2 + 4x3 + 5x4)
    # при ограничениях:
    #   2x1 + 3x2 + 4x3 + 5x4 <= 100  (Площадь)
    #   2x1 + 1x2 + 2x3 + 4x4 <= 120  (Труд)
    #   2x1 + 3x2 + 1x3 + 1x4 <= 80   (Тяга)
    # и xj >= 0.
    #
    # Функция simplex преобразует задачу к стандартной форме с введением слаговых переменных,
    # а затем решает её методом симплекс.

    production_plan, max_income, tableau, basis = simplex(income_coeff, resource_coeff, resources_available)
    
    # Вывод результатов:
    print("Оптимальный план производства:")
    for product, amount in zip(products, production_plan):
        print(f"{product}: {amount:.1f} единиц")

    print(f"\nМаксимальный доход: {max_income:.2f} денежных единиц")
    
    # Вычисляем фактическое использование ресурсов:
    used_resources = resource_coeff.dot(production_plan)
    
    print("\nИспользование ресурсов:")
    for name, used, avail in zip(resource_names, used_resources, resources_available):
        percentage = used / avail * 100
        print(f"{name}: {used:.1f} из {avail} ({percentage:.1f}%)")
    
    # Анализ лимитирующих ресурсов
    print("\nАнализ ограничений:")
    for name, used, avail in zip(resource_names, used_resources, resources_available):
        if abs(used - avail) < 1e-6:
            print(f"{name} является лимитирующим ресурсом (использован полностью)")
        else:
            print(f"{name} имеет резерв: {avail - used:.1f} единиц")

